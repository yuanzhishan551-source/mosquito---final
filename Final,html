<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosquito Slayer - New Fist</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            user-select: none;
        }

        #input_video { display: none; }

        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        /* --- 开屏界面样式 --- */
        #start-screen {
            position: absolute;
            z-index: 100;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            cursor: pointer;
            transition: opacity 0.5s ease;
        }

        #start-screen img {
            max-width: 30%;
            max-height: 30%;
            object-fit: contain;
        }
    </style>
</head>
<body>

    <!-- 开屏界面 -->
    <div id="start-screen">
        <img id="start-btn-img" src="" alt="Start Game">
    </div>

    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>

    <script>
        // --- 1. 开屏动画逻辑 ---
        const startScreen = document.getElementById('start-screen');
        const startBtnImg = document.getElementById('start-btn-img');
        
        const URL_START_1 = "https://raw.githubusercontent.com/yuanzhishan551-source/Mosquito2/main/Start1.png";
        const URL_START_2 = "https://raw.githubusercontent.com/yuanzhishan551-source/Mosquito2/main/Start%202.png";
        
        startBtnImg.src = URL_START_1;
        let isImgOne = true;

        const animationInterval = setInterval(() => {
            if (isImgOne) {
                startBtnImg.src = URL_START_2;
            } else {
                startBtnImg.src = URL_START_1;
            }
            isImgOne = !isImgOne;
        }, 1000);


        // --- Assets ---
        const IMG_SIDE_HAND = new Image();
        IMG_SIDE_HAND.src = "https://raw.githubusercontent.com/yuanzhishan551-source/Mosquito2/main/on%20side%20right%20hand%202.png";

        const IMG_OPEN_HAND = new Image();
        IMG_OPEN_HAND.src = "https://raw.githubusercontent.com/yuanzhishan551-source/Mosquito2/main/right%20hand%202.png";

        // --- 拳头图片 (已更新) ---
        const IMG_FIST = new Image();
        IMG_FIST.src = "https://raw.githubusercontent.com/yuanzhishan551-source/Mosquito2/main/bce995b79f0c8eda263e8dc5dc03755a.png";

        const IMG_CLAP_SUCCESS = new Image();
        IMG_CLAP_SUCCESS.src = "https://files.catbox.moe/mvf62w.png";

        const IMG_MOSQUITO = new Image();
        IMG_MOSQUITO.src = "https://files.catbox.moe/qyq34g.png";

        const IMG_BLOOD = new Image();
        IMG_BLOOD.src = "https://raw.githubusercontent.com/yuanzhishan551-source/Mosquito2/main/Blood.png";
        
        const AUDIO_MOSQUITO = new Audio("https://files.catbox.moe/tdee34.wav");
        AUDIO_MOSQUITO.loop = true;
        AUDIO_MOSQUITO.preload = 'auto';
        
        const AUDIO_SLAP = new Audio("https://files.catbox.moe/vbp11i.m4a");
        AUDIO_SLAP.preload = 'auto';

        // --- Game State ---
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.getElementById('input_video');
        
        let mosquito = { x: 0.5, y: 0.5, vx: 0.005, vy: 0.005, alive: true, respawnTimer: 0, deadX: 0, deadY: 0 };
        let clapEffect = { active: false, x: 0, y: 0, timer: 0 };
        let persistedHands = {};
        let gameStarted = false;
        
        let handStates = {
            0: { lastSize: 0, slapAnimTimer: 0, velocity: 0 },
            1: { lastSize: 0, slapAnimTimer: 0, velocity: 0 }
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function forcePlayAudio() {
            AUDIO_MOSQUITO.play().catch(error => {});
        }
        forcePlayAudio();
        document.addEventListener("WeixinJSBridgeReady", forcePlayAudio, false);

        function unlockAudio() {
            forcePlayAudio();
            AUDIO_SLAP.load();
            document.removeEventListener('click', unlockAudio);
            document.removeEventListener('touchstart', unlockAudio);
        }
        document.addEventListener('click', unlockAudio);
        document.addEventListener('touchstart', unlockAudio);

        // --- Game Start ---
        startScreen.addEventListener('click', () => {
            if(gameStarted) return;
            gameStarted = true;
            
            clearInterval(animationInterval);

            forcePlayAudio();
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.style.display = 'none';
            }, 500);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            camera.start();
        });

        // --- Logic ---
        function updateMosquito() {
            if (!mosquito.alive) {
                mosquito.respawnTimer++;
                if (mosquito.respawnTimer > 60) { 
                    mosquito.alive = true;
                    mosquito.x = Math.random() * 0.8 + 0.1;
                    mosquito.y = Math.random() * 0.8 + 0.1;
                    mosquito.respawnTimer = 0;
                    AUDIO_MOSQUITO.play();
                }
                return;
            }
            mosquito.x += mosquito.vx;
            mosquito.y += mosquito.vy;
            if (Math.random() < 0.05) mosquito.vx = (Math.random() - 0.5) * 0.015;
            if (Math.random() < 0.05) mosquito.vy = (Math.random() - 0.5) * 0.015;
            
            if (mosquito.x < 0.05) mosquito.vx = Math.abs(mosquito.vx);
            if (mosquito.x > 0.95) mosquito.vx = -Math.abs(mosquito.vx);
            if (mosquito.y < 0.05) mosquito.vy = Math.abs(mosquito.vy);
            if (mosquito.y > 0.95) mosquito.vy = -Math.abs(mosquito.vy);
        }

        function playSlapSound() {
            let sound = AUDIO_SLAP.cloneNode();
            sound.volume = 1.0;
            sound.play().catch(e => {});
        }

        function killMosquito() {
            if (!mosquito.alive) return;
            mosquito.alive = false;
            mosquito.deadX = mosquito.x;
            mosquito.deadY = mosquito.y;
            AUDIO_MOSQUITO.pause();
            AUDIO_MOSQUITO.currentTime = 0;
            playSlapSound();
        }

        // --- MediaPipe ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function onResults(results) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. Draw Mosquito (Size 30)
            updateMosquito();
            if (mosquito.alive) {
                const mx = mosquito.x * canvas.width;
                const my = mosquito.y * canvas.height;
                const mSize = 30; 
                ctx.save();
                ctx.translate(mx, my);
                const angle = Math.atan2(mosquito.vy, mosquito.vx);
                ctx.rotate(angle + Math.PI / 2);
                ctx.drawImage(IMG_MOSQUITO, -mSize/2, -mSize/2, mSize, mSize);
                ctx.restore();
            } else if (mosquito.respawnTimer > 0) {
                const bloodSize = 60; 
                const deadX = mosquito.deadX * canvas.width;
                const deadY = mosquito.deadY * canvas.height;
                ctx.drawImage(IMG_BLOOD, deadX - bloodSize/2, deadY - bloodSize/2, bloodSize, bloodSize);
                const mSize = 30; 
                ctx.save();
                ctx.translate(deadX, deadY);
                ctx.drawImage(IMG_MOSQUITO, -mSize/2, -mSize/2, mSize, mSize);
                ctx.restore();
            }

            // 2. Clap Effect
            if (clapEffect.active) {
                clapEffect.timer--;
                const baseSize = 300;
                const clapRatio = IMG_CLAP_SUCCESS.naturalWidth / IMG_CLAP_SUCCESS.naturalHeight || 1;
                const clapWidth = baseSize * clapRatio;
                const clapHeight = baseSize;
                ctx.drawImage(IMG_CLAP_SUCCESS, clapEffect.x - clapWidth/2, clapEffect.y - clapHeight/2, clapWidth, clapHeight);
                if (clapEffect.timer <= 0) clapEffect.active = false;
                return;
            }

            // 3. Process Hands
            persistedHands = {};
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const label = results.multiHandedness[index].label;
                    const wrist = landmarks[0];
                    const thumbTip = landmarks[4];
                    const middleMCP = landmarks[9];  
                    const middleTip = landmarks[12]; 
                    const pinkyMcp = landmarks[17];
                    const cx = landmarks[9].x; 
                    const cy = landmarks[9].y;

                    const wristToTip = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
                    const wristToKnuckle = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                    const handWidth = Math.hypot(thumbTip.x - pinkyMcp.x, thumbTip.y - pinkyMcp.y);

                    let ratio = 0.5;
                    if (wristToTip > 0) ratio = handWidth / wristToTip;
                    const isSide = ratio < 0.38;

                    const isFist = !isSide && (wristToTip < wristToKnuckle * 1.5);

                    let stableSize = wristToTip;
                    if (isFist) {
                        stableSize = wristToKnuckle * 2.5; 
                    }

                    let angle = Math.atan2(middleMCP.y - wrist.y, middleMCP.x - wrist.x);
                    angle += Math.PI / 2;

                    persistedHands[index] = {
                        x: cx, y: cy,
                        angle: angle,
                        label: label,
                        isSide: isSide,
                        isFist: isFist,
                        size: stableSize, 
                        landmarks: landmarks
                    };
                });
            }

            // 4. Render
            const handKeys = Object.keys(persistedHands);
            let currentHandsList = []; 

            handKeys.forEach(key => {
                const hand = persistedHands[key];
                const state = handStates[key];

                const screenX = hand.x * canvas.width;
                const screenY = hand.y * canvas.height;

                let isSlapping = false;
                let renderScale = 1.0;
                let shadowAlpha = 0.167; 
                let shadowOffset = 6.67; 

                if (!hand.isSide) {
                    const sizeDiff = hand.size - state.lastSize;
                    state.velocity = state.velocity * 0.6 + sizeDiff * 0.4;
                    
                    if (state.velocity > 0.008 && hand.size > 0.15 && state.slapAnimTimer === 0) {
                        state.slapAnimTimer = 10; 
                        playSlapSound(); 
                        const dist = Math.hypot(hand.x - mosquito.x, hand.y - mosquito.y);
                        if (dist < 0.2) killMosquito();
                    }

                    state.lastSize = hand.size;

                    if (state.slapAnimTimer > 0) {
                        isSlapping = true;
                        state.slapAnimTimer--;
                        renderScale = 0.85; 
                        shadowAlpha = 0;
                        shadowOffset = 0;
                    } 
                } else {
                    state.slapAnimTimer = 0;
                    state.lastSize = hand.size;
                }

                currentHandsList.push(hand);

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(hand.angle);
                
                if (hand.label === 'Left') ctx.scale(-1, 1); 
                if (hand.isFist) ctx.scale(-1, 1);

                let img = IMG_OPEN_HAND;
                if (hand.isSide) {
                    img = IMG_SIDE_HAND;
                } else if (hand.isFist) {
                    img = IMG_FIST;
                }

                if (!img.complete || img.naturalWidth === 0) {
                    img = IMG_OPEN_HAND; 
                }
                
                let baseHeight = 480 - (hand.size * 800);
                if (baseHeight < 120) baseHeight = 120;
                if (baseHeight > 450) baseHeight = 450;

                if (hand.isSide) {
                    baseHeight *= 2.0; 
                } 
                else if (hand.isFist) baseHeight *= 2.5; 
                else baseHeight *= 2.0;

                baseHeight *= renderScale;

                if (!hand.isSide) {
                    shadowOffset = (0.5 - hand.size) * 26.67; 
                    if (shadowOffset < 0) shadowOffset = 0;

                    ctx.shadowColor = `rgba(0, 0, 0, ${shadowAlpha})`;
                    ctx.shadowBlur = isSlapping ? 0 : 10;
                    
                    // --- 投影向右下偏移 8px ---
                    ctx.shadowOffsetX = shadowOffset + 8;
                    ctx.shadowOffsetY = shadowOffset + 8;
                }

                const ratio = img.naturalWidth / img.naturalHeight || 0.8;
                const drawWidth = baseHeight * ratio;
                const drawHeight = baseHeight;

                try {
                    ctx.drawImage(img, -drawWidth/2, -drawHeight/2, drawWidth, drawHeight);
                } catch (e) {}
                ctx.restore();
            });

            // 5. Clap Detection
            if (currentHandsList.length === 2) {
                const h1 = currentHandsList[0];
                const h2 = currentHandsList[1];
                if (h1.isSide || h2.isSide) {
                    const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                    if (dist < 0.15) {
                        clapEffect.active = true;
                        clapEffect.timer = 15;
                        clapEffect.x = (h1.x + h2.x) / 2 * canvas.width;
                        clapEffect.y = (h1.y + h2.y) / 2 * canvas.height;
                        
                        playSlapSound();
                        const mDist = Math.hypot(clapEffect.x/canvas.width - mosquito.x, clapEffect.y/canvas.height - mosquito.y);
                        if (mDist < 0.2) killMosquito();
                    }
                }
            }
        }
    </script>
</body>
</html>
